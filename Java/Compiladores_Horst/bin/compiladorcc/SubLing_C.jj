/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SubLing_C.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  STATIC = false;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(SubLing_C)
package compiladorcc;
import java.io.*;
import recovery.*;
import semantica.*;

public class SubLing_C/*@bgen(jjtree)*/implements SubLing_CTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTSubLing_CState jjtree = new JJTSubLing_CState();

/*@egen*/
  // contador de erros sint\ufffdticos
  int contParseError = 0;
  //controla verbose de recupera\ufffd\ufffdo de erros
  boolean debug_recovery; 
  
  public static void main(String args []) throws ParseException
  {
    boolean debug_as = false;
    boolean debug_recovery = false;

	//nome do arquivo a ser lido
    String filename = "";
    String arvore_arquivo;
    //analisador lexico e sintatico
    SubLing_C parser; 
    int i;
    boolean ms = false;

//l\ufffd os par\ufffdmetros passados para o compilador
    for ( i = 0; i < args.length-1; i++) {
		if(args[i].equals("-debug_AS")) {
		  debug_as = true;
		  break;
		}else {
		  System.out.println("Usage is: " + "java SubLing_C [-degub_AS] inputfile");
		  System.exit(0);
		}
    }

//l\ufffd da entrada padr\ufffdo
	if(args[i].equals("-")) { 
		 System.out.println("Reading from standard input...");
		 parser = new SubLing_C(System.in); //cria o analisador sint\ufffdtico
		 
	}else {
	  // l\ufffd do arquivo
	   filename = args[args.length-1];
	   System.out.println("Reading from file " + filename + ". . .");
	   
	   try {
	     // cria o analisador sint\ufffdtico
	     parser = new SubLing_C(new java.io.FileInputStream(filename));
	     
	   } catch (java.io.FileNotFoundException e) {
	     System.out.println("File " + filename + " not found.");
	     return;
	   }catch (IOException e) {
	     System.out.println("Erro ao abrir o aquivo." + e.getMessage());
	     return;
	   }
	 }

	parser.debug_recovery = debug_recovery;
	if(!debug_as) parser.disable_tracing(); //desabilita verbose do Analisador sint\ufffdtico

	
	SimpleNode root = null;

	try { 
		root = parser.program();
	}
	catch(ParseException e) {
		System.err.println(e.getMessage());
	}

    SimpleNode print = root;
	print.dump(filename); //imprime a arvore no arquivo
	  
	SemanticRun parseSem = new SemanticRun();

	try {
		parseSem.programCheck(root);
	}
	catch(SemanticException e) {
		System.out.println(e.getMessage());
	}

	finally {
	  System.out.println(parser.token_source.foundLexError() + " Lexical Errors found");
	  System.out.println(parser.contParseError + " Syntactic Errors found");
	  System.out.println(parseSem.getFoundSemanticError() + " Semantic Errors found");
	}
  }//main

  static public String im  (int x) {
    int k;
    String s;

    s = tokenImage[x];
    k = s.lastIndexOf("\"");

    try { s = s.substring(1,k); }
    catch (StringIndexOutOfBoundsException e) { }
    return s;
  }

  boolean eof; //vari\ufffdvel que indica se EOF foi alcan\ufffdado
 

/**
* consumeUntil, consome tokenns at\ufffd alcan\ufffdar um que perten\ufffda ao conjunto de sincroniza\ufffd\ufffdo
* @param g, conjunto de sincroniza\ufffd\ufffdo que ser\ufffd usado
* @param e, descreve o erro sint\ufffdtico que ocorreu
* @oaram met, n\ufffdo terminal que faz a recupera\ufffd\ufffdo dos erros
* @pre-condition nenhuma
* @post-condition nenhuma
*/
 void consumeUntil(RecoverySet g, ParseException e, String met) throws /*/*ParseEOFException*/ ParseException{
 	Token tok;
 		if(debug_recovery){ //informa sobre a recupera\ufffd\ufffdo
 			System.out.println();
 			System.out.println("*** " + met+ "***");
 			System.out.println("	Syncronizing Set: " + g);
 		}
 		if(g == null) throw e; // se o conjunto \ufffd nulo, propaga a exce\ufffd\ufffdo

 		tok = getToken(1); //pega token corrente
 		while(!eof){ //se n\ufffdo chegou ao fim do arquivo
 			if(g.contains(tok.kind)) { //acha um token no conjunto
 				if(debug_recovery){
 					System.out.println("	found Syncronizing token: " + im(tok.kind));
 					break;
 				}
 			}
 			if(debug_recovery){
 					System.out.println("	ignoring token: " + im(tok.kind));
 			}
 			getNextToken(); 
 			tok = getToken(1);
 			if(tok.kind == EOF && !g.contains(EOF)) eof = true;
 		}
 		System.out.println(e.getMessage());
 		contParseError++;
 		//if(eof) throw new /*ParseEOFException*/("EOF found prematurely.");
 }
}//SubLing_C

PARSER_END(SubLing_C)

/**
* TOKEN_MGR_DECLS, Introduz c\ufffddigo java na classe correspondente ao analisador l\ufffdxico
* @pre-condition nenhuma
* @post-condition nenhuma
* @return n\ufffdmero de erro lexico encontrado no arquivo que est\ufffd sendo analisado
*/
TOKEN_MGR_DECLS : {
	int countLexError= 0;

	public int foundLexError() {
		return countLexError;
	}
}

/**
* SKIP, Define quais cadeias dever\ufffdo ser ignoradas e n\ufffdo v\ufffdo entrar no reconhecimento de token 
* @pre-condition nenhuma
* @post-condition nenhuma
*/
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

/**
* TOKEN, Define conjunto de operadores a serem reconhecidos
* @pre-condition nenhuma
* @post-condition nenhuma
*/
TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < AND : "&&" >
| < OR : "||" >
| < NOT : "!" >
| < ASSIGNMENT : "=" >
| < ASSIGNMENT_PLUS : "+=" >
| < ASSIGNMENT_MINUS : "-=" >
| < ASSIGNMENT_MULTIPLY : "*=" >
| < ASSIGNMENT_DIVIDE : "/=" >
| < GT : ">" >
| < LT : "<" >
| < GE : ">=" >
| < LE : "<=" >
| < EQ : "==" >
| < NEQ : "!=" >
}

/**
* TOKEN, define conjunto de palavras reservadas a serem reconhecidas e as express\ufffdes que as define s\ufffdo as pr\ufffdprias palavras
* @pre-condition nenhuma
* @post-condition nenhuma
*/
TOKEN : /*PALAVRA RESERVADA*/
{
  < INT : "int" >
| < CHAR : "char" >
| < IF : "if" >
| < ELSE : "else" >
| < SWITCH : "switch" >
| < CASE : "case" >
| < BREAK : "break" >
| < FOR : "for" >
| < WHILE : "while" >
| < VOID : "void" >
| < RETURN : "return" >
| < DEFAULTT : "default" >
}

/**
* TOKEN, define conjunto de s\ufffdmbolos especiais a serem reconhecidos
* @pre-condition nenhuma
* @post-condition nenhuma
*/
TOKEN : /*SIMBOLOS ESPECIAIS*/
{
  < L_PAREN : "(" >
| < R_PAREN : ")" >
| < L_CHAV : "[" >
| < R_CHAV : "]" >
| < L_COLC : "{" >
| < R_COLC : "}" >
| < PONT_VIRG : ";" >
| < TWO_PONT : ":" >
| < VIRG : "," >
}

/**
* TOKEN, define conjunto de constantes a serem reconhecidas
* @pre-condition nenhuma
* @post-condition nenhuma
*/ 
TOKEN : /*CONSTANTES*/
{
  // constantes n\ufffdmeros
  < INT_CONSTANT : (< DIGIT >)+ >

  // constantes string 
| < CHAR_CONSTANT : "\""( ~["\"","\n","\r"])* "\"" >
| < NULL_CONSTANT : "null" >
| < #DIGIT : [ "0"-"9" ] >
| < #CARACTERES : ["A" - "Z","a"-"z"] >
}

/**
* TOKEN, define conjunto de identificadores a serem reconhecidos
* @pre-condition nenhuma
* @post-condition nenhuma
*/ 
TOKEN : /*IDENTIFICADORES*/
{
  < IDENT : < CARACTERES > (< CARACTERES > | < DIGIT >)* >
}

/**
* SPECIAL_TOKEN, trata os erros l\ufffdxicos, significa que n\ufffdo \ufffd passado para o analisador l\ufffdxico mas \ufffd armazenado
* @var ~, indica que o casamento \ufffd feito quando os caracter  de entrada n\ufffdo est\ufffd no conjunto definido entre os colchetes
* @var +, indica que a repeti\ufffd\ufffdo ocorrer\ufffd pelo menos uma vez
* @pre-condition nenhuma
* @post-condition nenhuma
*/ 
SPECIAL_TOKEN : /*TRATA OS ERROS LEXICOS*/
{
  < INVALID_LEXICAL :
  (
    ~["a"-"z" , "A"-"Z",
    "0"-"9",
    "\"",
    "(", ")",
    "[", "]",
    "{", "}",
    ";", ":", ",",
    ">", "<",
    "=", "!",
    "+", "-", "*", "/",
    " ", "\t", "\n", "\r"]
  )+ >
	{
	  System.err.println("Line " + input_stream.getEndLine() + " - Invalid string found: " + image);
	  countLexError++;
	}
}

/**
* program, \ufffd um n\ufffdo-terminal que ap\ufffds reconhecer o functlist na entrada, ele tenta achar o EOF,
* @pre-condition: nenhuma
* @post-condition: se n\ufffdo conseguir achar o EOF dever\ufffd fazer a ressincroniza\ufffd\ufffdo e voltar a analisar o programa
*/ 
SimpleNode program()          : {/*@bgen(jjtree) PROGRAMA */
        SimpleNode jjtn000 = new SimpleNode(JJTPROGRAMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet g = First.program;
}
{/*@bgen(jjtree) PROGRAMA */
 try {
/*@egen*/
 (
    < EOF > |  functlist(g)
	try{
		< EOF > 
	}catch(ParseException e){
		consumeUntil(g, e, "program");
	}
	[program()]
)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/**
* functlist, \ufffd um n\ufffdo terminal que diz que o programa \ufffd formado por uma lista de fun\ufffd\ufffdes, seguido pelo EOF
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: o erro \ufffd tratado 
*/
void functlist(RecoverySet g)            : {/*@bgen(jjtree) FUNCT_LIST */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCT_LIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet f = First.functlist.union(g);
}
{/*@bgen(jjtree) FUNCT_LIST */
  try {
/*@egen*/
  (
   // functdecl passa como conjunto de sincroniza\ufffd\ufffdo o conjunto g que foi passado como parametro
  // ap\ufffds functdecl, o functlist pode ou n\ufffdo ocorrer  
  functdecl(f) [functlist(g)]
)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

/**
* functdecl, define como formar a assinatura da fun\ufffd\ufffdo
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: 
*/ 
void functdecl(RecoverySet g)            : {/*@bgen(jjtree) FUNCT_DECL */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCT_DECL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ //assinatura da fun\ufffd\ufffdo
	RecoverySet f = new RecoverySet (R_PAREN);
	RecoverySet h = new RecoverySet (IDENT);
	Token t;
}
{/*@bgen(jjtree) FUNCT_DECL */
  try {
/*@egen*/
  try { 
		functype(h) t = <IDENT> <L_PAREN> paramlist(f) < R_PAREN >  < L_COLC > functbody(g) < R_COLC >
		{
		  jjtn000.value1 = t.image;
		}
	}catch (ParseException e) {
	  consumeUntil(g, e, "functdecl");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


/**
* paramlist, define como formar a lista de par\ufffdmetros
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void paramlist(RecoverySet g)            : {/*@bgen(jjtree) PARAM_LIST */
        SimpleNode jjtn000 = new SimpleNode(JJTPARAM_LIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ // lista de parametros
	RecoverySet f = new RecoverySet (IDENT);
	Token t1 = null, t2 = null;
}
{/*@bgen(jjtree) PARAM_LIST */
  try {
/*@egen*/
  try { 
  	[functype(f) t1 = <IDENT> (< L_CHAV > <R_CHAV >)* (< VIRG > functype(f) t2 = < IDENT > (< L_CHAV ><R_CHAV >)*)*]
  	{
  	  if(t1 != null) { 
  	  	jjtn000.value1 = t1.image;
	  	if(t2 != null) jjtn000.value2 = t2.image;
		}
  	}
  }catch(ParseException e) {
    consumeUntil(g, e, "paramlist");
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* varlist, demonstra como declarar uma vari\ufffdvel
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void varlist(RecoverySet g)          : {/*@bgen(jjtree) VAR_LIST */
        SimpleNode jjtn000 = new SimpleNode(JJTVAR_LIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ //declara\ufffd\ufffdo de variavel
	Token tipo, nome;
}
{/*@bgen(jjtree) VAR_LIST */
        try {
/*@egen*/
  	try { 
    	(tipo = < VOID > | tipo = < INT > | tipo = < CHAR > ) nome = <IDENT> (< L_CHAV >(<INT_CONSTANT>)+<R_CHAV >)*
    	{
    	  jjtn000.value1 = tipo.image;
    	  jjtn000.value2 = nome.image;
    	}
   }catch(ParseException e) {
     consumeUntil (g, e, "varlist");
   }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* functype, define qual ser\ufffd o tipo das vari\ufffdveis
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: tipo da vari\ufffdvel \ufffd definido
*/
void functype(RecoverySet g)             :
{/*@bgen(jjtree) FUNCT_TYPE */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCT_TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token tipo;
} //tipos de variaveis
{/*@bgen(jjtree) FUNCT_TYPE */
  try {
/*@egen*/
  try { 
  	tipo = < VOID > | tipo = < INT > | tipo = < CHAR > | tipo = < IDENT >
  	{
  	  jjtn000.value1 = tipo.image;
  	}
 }catch(ParseException e) {
   consumeUntil (g, e, "functype");
 }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* functbody, define como ser\ufffd definido o corpo do fun\ufffd\ufffdo
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: corpo da fun\ufffd\ufffdo \ufffd definido
*/ 
void functbody(RecoverySet g)            : {/*@bgen(jjtree) FUNCT_BODY */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCT_BODY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet f = new RecoverySet(PONT_VIRG);
}
{/*@bgen(jjtree) FUNCT_BODY */
try {
/*@egen*/
try {  	
  	(
  	varlist(f) <PONT_VIRG>
|	comand_if(g)
|	comand_switch(g)
| 	comand_for(g)
| 	comand_while(g)
| 	atrib(f) < PONT_VIRG >
| 	< BREAK > <PONT_VIRG >
| 	Return(f)< PONT_VIRG >
	)*
	}catch(ParseException e) {
		consumeUntil (g, e, "functbody");
	}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/**
* return, define como o comando "return" funcionar\ufffd
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void Return(RecoverySet g)         : {/*@bgen(jjtree) RETURN */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) RETURN */
  try {
/*@egen*/
  try { 
  	< RETURN > expressao(g)
 }catch(ParseException e) {
   consumeUntil (g, e, "Return");
 }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* comand_if, define como o comando "if" funcionar\ufffd
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void comand_if(RecoverySet g)    : {/*@bgen(jjtree) IF */
        SimpleNode jjtn000 = new SimpleNode(JJTIF);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet f1 = new RecoverySet(R_PAREN), f2 = new RecoverySet(ELSE).union(g);
}
{/*@bgen(jjtree) IF */
  try {
/*@egen*/
  try { 
  	< IF > <L_PAREN > expressao(f1) < R_PAREN > <L_COLC> functbody(f2) <R_COLC> [< ELSE > <L_COLC>functbody(g)<R_COLC>]
 }catch(ParseException e) {
	consumeUntil(g, e, "comand_if");
 }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* comand_switch, define como o comando "switch" funcionar\ufffd 
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void comand_switch(RecoverySet g)        : {/*@bgen(jjtree) SWITCH */
        SimpleNode jjtn000 = new SimpleNode(JJTSWITCH);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet f = new RecoverySet(PONT_VIRG);
	Token t;
}
{/*@bgen(jjtree) SWITCH */
  try {
/*@egen*/
  try { 
	  < SWITCH > < L_PAREN > t= < IDENT > < R_PAREN > <L_COLC >
	  (
	    < CASE > (< INT_CONSTANT > | < CHAR_CONSTANT >) < TWO_PONT >
		(atrib(f)<PONT_VIRG >)+
	  < BREAK > <PONT_VIRG >
	  )+
	  < DEFAULTT > < TWO_PONT >(atrib(f) < PONT_VIRG >)+
	  < R_COLC >
	  {
	    jjtn000.value1 = t.image;
	  }
	}catch(ParseException e) {
	  consumeUntil(g, e, "comand_switch");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* comand_for, define como o comando "for" funcionar\ufffd
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma 
*/ 
void comand_for(RecoverySet g)      : {/*@bgen(jjtree) FOR */
        SimpleNode jjtn000 = new SimpleNode(JJTFOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet f1 = new RecoverySet(PONT_VIRG), f2 = new RecoverySet(R_COLC);
}
{/*@bgen(jjtree) FOR */
  try {
/*@egen*/
  try { 
		<FOR> <L_PAREN> [atrib(f1)] <PONT_VIRG>
						[expressao(f1)] <PONT_VIRG>
						[atrib(f2)] <R_PAREN>
		<L_COLC> functbody(g) <R_COLC>
	}catch(ParseException e) {
	  consumeUntil(g, e, "comand_for");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* comand_while, define como o comando "while" funcionar\ufffd
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void comand_while(RecoverySet g)       : {/*@bgen(jjtree) WHILE */
        SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	RecoverySet f = new RecoverySet(R_PAREN);
}
{/*@bgen(jjtree) WHILE */
  try {
/*@egen*/
  try { 
		<WHILE> <L_PAREN> expressao(f) <R_PAREN>
		<L_COLC> functbody(g) <R_COLC>
	}catch(ParseException e) {
		consumeUntil(g, e, "comand_while");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* atrib, faz atribui\ufffd\ufffdo, uma vari\ufffdvel que recebe alguma express\ufffdo
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/
void atrib(RecoverySet g)            : {/*@bgen(jjtree) ATRIBUICAO */
  SimpleNode jjtn000 = new SimpleNode(JJTATRIBUICAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ATRIBUICAO */
  try {
/*@egen*/
  try { 
	< IDENT > ( < ASSIGNMENT > | < ASSIGNMENT_PLUS > | < ASSIGNMENT_MINUS > | < ASSIGNMENT_MULTIPLY > | < ASSIGNMENT_DIVIDE >) expressao(g)
	}catch(ParseException e) {
	  consumeUntil(g, e, "atrib");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

/**
* expressao, monta as express\ufffdes matem\ufffdticas e booleanas
* @param g, nome do conjunto de tokens de sincroniza\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: express\ufffdes matem\ufffdtica e booleanas s\ufffdo formadas
*/
void expressao(RecoverySet g)           : {/*@bgen(jjtree) EXPRESSAO */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) EXPRESSAO */
  try {
/*@egen*/
  try { 
	numexpr() [( < LT > | < GT > | < LE > | < GE > | < EQ > | < NEQ > | < AND > | < OR > ) numexpr()]
	}catch(ParseException e) {
	  consumeUntil(g, e, "expressao");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
* numexpr, indica a a\ufffd\ufffdo de soma e subtra\ufffd\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void numexpr()                  : {/*@bgen(jjtree) NUMERO_EXPRESSAO */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMERO_EXPRESSAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NUMERO_EXPRESSAO */
        try {
/*@egen*/
	term() ((< PLUS > | < MINUS >) term())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* term, indica a a\ufffd\ufffdo de multiplica\ufffd\ufffdo e divis\ufffdo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/ 
void term()       : {/*@bgen(jjtree) TERM */
  SimpleNode jjtn000 = new SimpleNode(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) TERM */
        try {
/*@egen*/
	unaryexpr() ((< MULTIPLY > | < DIVIDE >) unaryexpr())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* unaryexpr, indica se o n\ufffdmero \ufffd positivo ou negativo
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/
void unaryexpr()            : {/*@bgen(jjtree) UNARY_EXPR */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARY_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) UNARY_EXPR */
        try {
/*@egen*/
	[(< PLUS > | < MINUS >)] factor()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* factor, garate que a divis\ufffdo seja feita por primeiro
* @pre-condition: nenhuma
* @post-condition: nenhuma
*/
void factor()        : {/*@bgen(jjtree) FACTOR */
  SimpleNode jjtn000 = new SimpleNode(JJTFACTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) FACTOR */
        try {
/*@egen*/
	[< NOT >]( < INT_CONSTANT > |  < CHAR_CONSTANT > |  < NULL_CONSTANT > | < IDENT > | < L_PAREN > expressao(null) < R_PAREN >)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}